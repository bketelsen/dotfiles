# Phase 5: Shell Configuration - Research

**Researched:** 2026-02-04
**Domain:** Shell configuration (zsh/bash) with cross-shell compatibility
**Confidence:** HIGH

## Summary

Shell configuration for zsh (macOS) and bash (Linux) requires careful attention to startup performance, cross-shell compatibility, and modular organization. The standard approach uses dedicated startup files (.zshrc for zsh, .bashrc for bash) with tool integrations loaded conditionally based on tool presence. Modern shell configuration prioritizes startup speed (target: <200ms) through techniques like deferred loading, completion caching, and avoiding command execution during startup.

The established pattern for cross-shell compatibility uses chezmoi templates to generate shell-specific files from shared templates, with a functions.d directory pattern for modular function organization. zsh-specific enhancements (autosuggestions, syntax highlighting) are installed via Homebrew and sourced directly for performance, avoiding the overhead of plugin managers like Oh My Zsh.

Tool integration follows a conditional initialization pattern where tools like starship, atuin, direnv, and fzf are initialized only if installed, with explicit handling of keybinding conflicts (particularly atuin and fzf both wanting Ctrl-R).

**Primary recommendation:** Use chezmoi templates for shell-specific generation, source zsh plugins directly from Homebrew installations, organize functions in functions.d directories sourced via loops, and profile startup time with zprof/time to maintain sub-200ms performance.

## Standard Stack

The established tools for shell configuration in 2026:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| zsh | 5.8+ | macOS default shell | Built-in on macOS, mature completion system, extensive customization |
| bash | 5.0+ | Linux default shell | POSIX compliant, universal availability, stable scripting environment |
| chezmoi | 2.x | Dotfile management | Template-based multi-OS support, handles shell-specific variations |
| starship | 1.22+ | Cross-shell prompt | Fast (Rust), works identically on zsh/bash, minimal config |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| zsh-autosuggestions | latest | Fish-like command suggestions | zsh only - fish-style history suggestions |
| zsh-syntax-highlighting | latest | Real-time syntax validation | zsh only - instant feedback on command validity |
| fzf | 0.48.0+ | Fuzzy finding | Both shells - file/directory/history search |
| bat | latest | cat replacement with syntax highlighting | Both shells - modern file viewing |
| eza | latest | ls replacement | Both shells - modern directory listing |
| fd | latest | find replacement | Both shells - simpler file searching |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Direct sourcing | Oh My Zsh | OMZ adds 200-500ms startup time, direct sourcing <50ms |
| Direct sourcing | zinit/zplugin | Turbo mode defers loading (faster perceived startup) but adds complexity |
| Homebrew install | Git clone | Homebrew handles updates, git clone gives version control |
| functions.d loop | Single large file | Modular is maintainable, single file is microseconds faster |

**Installation:**
```bash
# macOS via Homebrew
brew install zsh-autosuggestions zsh-syntax-highlighting fzf bat eza fd

# Linux via Homebrew (already configured in Phase 4)
brew install fzf bat eza fd
```

## Architecture Patterns

### Recommended Project Structure
```
~/.config/
├── starship.toml           # Starship prompt config (Phase 4)
└── atuin/                  # Atuin history config (Phase 4)

~/
├── .zshrc                  # Generated by chezmoi
├── .bashrc                 # Generated by chezmoi
├── .zsh/
│   └── functions.d/        # zsh-specific functions
│       ├── git.sh          # Git helper functions
│       ├── nav.sh          # Navigation shortcuts
│       └── utils.sh        # General utilities
└── .bash/
    └── functions.d/        # bash-specific functions
        ├── git.sh          # Same functions, bash-compatible
        ├── nav.sh          # Same functions, bash-compatible
        └── utils.sh        # Same functions, bash-compatible
```

### Pattern 1: Shell Startup File Organization
**What:** Separate concerns across zsh/bash startup files based on shell type (login vs non-login)

**When to use:** All shell configurations

**zsh startup order:**
1. `.zshenv` - ALL shells (interactive/non-interactive, login/non-login) - use for PATH, critical env vars
2. `.zprofile` - Login shells only - use for one-time setup
3. `.zshrc` - Interactive shells - use for aliases, functions, prompt, tool integrations
4. `.zlogin` - Login shells after .zshrc - rarely needed

**bash startup order:**
1. Login shell: `/etc/profile` → `~/.bash_profile` OR `~/.bash_login` OR `~/.profile` (first found)
2. Non-login interactive: `~/.bashrc`
3. Best practice: `.bash_profile` sources `.bashrc` so all interactive shells get same config

**Example (.zshrc structure):**
```zsh
# Source: Multiple zsh performance guides
# 1. Profiling (comment out when not needed)
# zmodload zsh/zprof

# 2. Environment (already in .zshenv, but can be here for interactive-only vars)

# 3. PATH modifications (use typeset -U to deduplicate)
typeset -U path
path=(
  $HOME/.local/bin
  $HOME/bin
  $path
)

# 4. Tool integrations (conditional on tool existence)
if command -v starship >/dev/null 2>&1; then
  eval "$(starship init zsh)"
fi

# 5. zsh-specific plugins (source at end for syntax-highlighting)
if [[ -f $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then
  source $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh
fi

# 6. Functions (loop through functions.d)
if [[ -d "$HOME/.zsh/functions.d" ]]; then
  for func_file in $HOME/.zsh/functions.d/*.sh; do
    [[ -f "$func_file" ]] && source "$func_file"
  done
fi

# 7. Aliases
source $HOME/.zsh/aliases.zsh

# 8. Completions initialization (with caching)
autoload -Uz compinit
if [[ -n ${ZDOTDIR}/.zcompdump(#qN.mh+24) ]]; then
  compinit
else
  compinit -C
fi

# 9. zsh-syntax-highlighting MUST be last
if [[ -f $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]]; then
  source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
fi

# 10. Profiling output (comment out when not needed)
# zprof
```

### Pattern 2: Chezmoi Template for Cross-Shell Files
**What:** Use chezmoi templates to generate shell-specific files from shared logic

**When to use:** When the same aliases/functions work on both shells

**Example (dot_zshrc.tmpl):**
```bash
# Source: chezmoi documentation
{{- if eq .chezmoi.os "darwin" }}
# macOS-specific zsh configuration

# Homebrew paths
eval "$(/opt/homebrew/bin/brew shellenv)"

# zsh plugins (macOS only)
source $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh
source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
{{- end }}

# Shared configuration (works on all OSes)
# Tool integrations
{{ if lookPath "starship" -}}
eval "$(starship init zsh)"
{{ end -}}

{{ if lookPath "atuin" -}}
eval "$(atuin init zsh)"
{{ end -}}

# Shared functions
for func_file in $HOME/.zsh/functions.d/*.sh; do
  [[ -f "$func_file" ]] && source "$func_file"
done
```

### Pattern 3: functions.d Auto-Sourcing
**What:** Modular function organization with automatic loading via loop

**When to use:** When you have multiple function groups (git, navigation, utilities)

**Example (.zsh/functions.d/git.sh):**
```bash
# Source: Common shell patterns
# Git shortcuts
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git pull'
alias gd='git diff'
alias gco='git checkout'
alias gb='git branch'

# Git functions
gac() {
  git add -A && git commit -m "$*"
}

gcp() {
  git add -A && git commit -m "$*" && git push
}
```

**Loading pattern (.zshrc):**
```bash
# Auto-source all function files
if [[ -d "$HOME/.zsh/functions.d" ]]; then
  for func_file in $HOME/.zsh/functions.d/*.sh; do
    [[ -f "$func_file" ]] && source "$func_file"
  done
fi
```

### Pattern 4: Conditional Tool Initialization
**What:** Only initialize tools if they're installed, avoid errors on systems without them

**When to use:** All tool integrations (starship, atuin, direnv, fzf)

**Example:**
```bash
# Source: Common shell configuration patterns
# Check if command exists before initializing
if command -v starship >/dev/null 2>&1; then
  eval "$(starship init zsh)"
fi

if command -v atuin >/dev/null 2>&1; then
  eval "$(atuin init zsh)"
fi

if command -v direnv >/dev/null 2>&1; then
  eval "$(direnv hook zsh)"
fi

# fzf - disable Ctrl-R if atuin is present
if command -v fzf >/dev/null 2>&1; then
  if command -v atuin >/dev/null 2>&1; then
    # Atuin handles Ctrl-R, disable fzf's binding
    export FZF_CTRL_R_COMMAND=""
  fi
  eval "$(fzf --zsh)"
fi
```

### Pattern 5: Login Shell Detection and Verbose Output
**What:** Show status on first shell after login, silent on subsequent shells

**When to use:** When implementing the "verbose on login, silent otherwise" requirement

**Example:**
```bash
# Source: Shell login detection patterns
# Detect login shell
if [[ -o login ]]; then
  # First shell after login - show status
  echo "Shell initialized:"
  command -v starship >/dev/null 2>&1 && echo "  ✓ starship" || echo "  ✗ starship (missing)"
  command -v atuin >/dev/null 2>&1 && echo "  ✓ atuin" || echo "  ✗ atuin (missing)"
  command -v direnv >/dev/null 2>&1 && echo "  ✓ direnv" || echo "  ✗ direnv (missing)"
  command -v fzf >/dev/null 2>&1 && echo "  ✓ fzf" || echo "  ✗ fzf (missing)"
  command -v bat >/dev/null 2>&1 && echo "  ✓ bat" || echo "  ✗ bat (missing)"
  command -v eza >/dev/null 2>&1 && echo "  ✓ eza" || echo "  ✗ eza (missing)"
  command -v fd >/dev/null 2>&1 && echo "  ✓ fd" || echo "  ✗ fd (missing)"
fi

# For bash, use different detection:
if shopt -q login_shell; then
  # Login shell - show status
  echo "Bash initialized..."
fi
```

### Pattern 6: PATH Deduplication
**What:** Prevent duplicate entries in PATH when shells are nested

**When to use:** Always when modifying PATH in zsh/bash

**zsh example:**
```bash
# Source: zsh documentation
# typeset -U makes array unique
typeset -U path
path=(
  $HOME/.local/bin
  $HOME/bin
  $path
)
```

**bash example:**
```bash
# Source: Common bash patterns
# Function to add to PATH only if not present
add_to_path() {
  if [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="$1:$PATH"
  fi
}

add_to_path "$HOME/.local/bin"
add_to_path "$HOME/bin"
```

### Pattern 7: Completion System Optimization (zsh)
**What:** Cache completion dump, only regenerate once per day

**When to use:** zsh configurations to improve startup speed

**Example:**
```bash
# Source: https://gist.github.com/ctechols/ca1035271ad134841284
autoload -Uz compinit
# Check if .zcompdump is older than 24 hours
if [[ -n ${ZDOTDIR:-$HOME}/.zcompdump(#qN.mh+24) ]]; then
  compinit
else
  compinit -C
fi
```

### Anti-Patterns to Avoid
- **Running commands in startup files:** `$(brew --prefix)` adds 10-20ms every shell. Cache the result: `HOMEBREW_PREFIX="/opt/homebrew"`
- **Sourcing syntax-highlighting early:** Must be last in .zshrc or it won't work correctly
- **Using Oh My Zsh for simple setups:** Adds 200-500ms, direct sourcing is <50ms
- **Not deduplicating PATH:** Nested shells accumulate duplicate entries, slowing down command lookup
- **Using eval without checking tool exists:** Causes errors on systems without the tool
- **Blocking operations in .envrc:** direnv should run in <100ms, no network calls or heavy computation

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Command history search | Custom fzf/grep script | atuin (Phase 4) | Sync across machines, SQLite backend, context-aware search |
| Prompt customization | Custom PS1/PROMPT code | starship (Phase 4) | Cross-shell, fast, Git-aware, extensive modules |
| Directory-specific env vars | Source .env files | direnv (Phase 4) | Security (explicit allow), automatic load/unload, stdlib functions |
| Fuzzy finding | Custom find/grep | fzf | Optimized C implementation, multiple integration modes, keybindings |
| Syntax highlighting (cat) | ANSI color codes | bat | Git integration, automatic paging, language detection |
| Better ls output | Format ls with colors | eza | Tree view, Git status, icons, group directories |
| File searching | Complex find expressions | fd | Respects .gitignore, simpler syntax, parallel execution |
| PATH deduplication | Custom loops | typeset -U (zsh) | Built-in, fast, handles edge cases |
| Completion caching | Manual cache logic | compinit -C with time check | Official zsh pattern, well-tested |

**Key insight:** Shell configuration has decades of battle-tested patterns. Modern tools (starship, atuin, direnv, fzf, bat, eza, fd) solve complex problems with simple interfaces. Custom solutions miss edge cases and require ongoing maintenance.

## Common Pitfalls

### Pitfall 1: Slow Startup Time
**What goes wrong:** Shell takes 500ms-2s to start, feels sluggish opening new terminals

**Why it happens:**
- Running commands during startup (especially `brew --prefix`, `nvm init`, `go env`)
- Oh My Zsh loading dozens of plugins
- Not caching completion dumps
- No profiling to identify bottlenecks

**How to avoid:**
- Profile with zprof (zsh) or `time bash -i -c exit` (bash)
- Target <200ms startup time
- Cache command outputs: `HOMEBREW_PREFIX="/opt/homebrew"` instead of `$(brew --prefix)`
- Use direct sourcing instead of Oh My Zsh
- Cache completions daily: check .zcompdump modification time

**Warning signs:**
- Noticeable delay before prompt appears
- `time zsh -i -c exit` shows >200ms
- zprof shows functions taking >50ms each

### Pitfall 2: Duplicate PATH Entries
**What goes wrong:** PATH grows with nested shells, command lookup slows, echo $PATH shows duplicates

**Why it happens:**
- Shell config appends to PATH without checking for duplicates
- Nested shells (tmux, vim terminal, subshells) each source config
- PATH accumulates: `/usr/bin:/usr/bin:/usr/bin...`

**How to avoid:**
- zsh: Use `typeset -U path` at start of PATH modifications
- bash: Check before adding: `[[ ":$PATH:" != *":$dir:"* ]] && PATH="$dir:$PATH"`
- Don't modify PATH in both .zshenv and .zshrc (choose one)

**Warning signs:**
- `echo $PATH | tr ':' '\n' | sort | uniq -d` shows duplicates
- PATH is very long when echoed

### Pitfall 3: Tool Initialization Order Errors
**What goes wrong:**
- zsh-syntax-highlighting doesn't work (wrong order)
- fzf and atuin both bind Ctrl-R (conflict)
- direnv shows errors when tool not installed

**Why it happens:**
- zsh-syntax-highlighting MUST be sourced last
- Multiple tools want same keybinding
- Conditional checks missing for tool presence

**How to avoid:**
- Source zsh-syntax-highlighting as absolute last thing in .zshrc
- Disable fzf Ctrl-R when atuin is present: `export FZF_CTRL_R_COMMAND=""`
- Always check tool exists: `if command -v tool >/dev/null 2>&1; then`
- Document initialization order in config file

**Warning signs:**
- Syntax highlighting not working
- Keybindings conflict (wrong tool responds)
- Errors on machines without certain tools

### Pitfall 4: Cross-Shell Incompatibilities
**What goes wrong:** Function works in zsh, breaks in bash (or vice versa)

**Why it happens:**
- Using zsh-specific syntax (`[[` vs `[`, array handling)
- Using bash-specific features
- Not testing on both shells

**How to avoid:**
- Use POSIX-compatible syntax for shared functions
- Test functions on both zsh and bash
- Keep shell-specific features in shell-specific files
- Use chezmoi templates to generate different versions when needed

**Warning signs:**
- Syntax errors when switching shells
- Functions silently fail on one shell
- Different behavior between shells

### Pitfall 5: direnv Performance Issues
**What goes wrong:** Slow directory changes, direnv blocks for seconds

**Why it happens:**
- Running network calls in .envrc (curl, wget)
- Running package managers in .envrc (npm install, bundle install)
- Heavy computation in .envrc

**How to avoid:**
- .envrc should complete in <100ms
- Never run npm install, bundle install, etc. in .envrc
- Don't make network calls
- Use direnv stdlib functions (PATH_add, etc.) instead of manual export
- Profile .envrc: `time direnv exec . true`

**Warning signs:**
- Noticeable delay when changing directories
- direnv warnings about execution time
- Manual "allow" feels slow

### Pitfall 6: Functions.d Organization Chaos
**What goes wrong:** Unclear which file contains which function, naming conflicts

**Why it happens:**
- No consistent naming scheme
- Functions in wrong categories
- No documentation in function files

**How to avoid:**
- Organize by purpose: git.sh, nav.sh, utils.sh, docker.sh
- Add header comments in each file describing contents
- One logical group per file
- Alphabetize functions within files

**Warning signs:**
- Searching for function definitions takes time
- Functions in unexpected files
- Duplicate function names across files

### Pitfall 7: Alias Shadowing Without Escape Hatch
**What goes wrong:** Can't run original command, alias always runs

**Why it happens:**
- Creating alias like `alias cat=bat` without knowing how to bypass it

**How to avoid:**
- Know escape methods: `\cat`, `command cat`, `/usr/bin/cat`
- Document shadowing aliases with comments
- Consider new names for drastically different behavior: `bat` instead of aliasing `cat`
- Test that original still works: `\ls` when `alias ls=eza`

**Warning signs:**
- Scripts break because they expect original command
- Can't figure out how to use original command
- Unexpected behavior from system utilities

## Code Examples

Verified patterns from official sources and community best practices:

### Login Shell Detection and Status Output
```bash
# Source: Shell startup file documentation, login detection patterns

# zsh - detect login shell
if [[ -o login ]]; then
  echo "=== Shell Environment Initialized ==="
  echo ""
  echo "Tools:"
  command -v starship >/dev/null 2>&1 && echo "  ✓ starship" || echo "  ✗ starship (not found)"
  command -v atuin >/dev/null 2>&1 && echo "  ✓ atuin" || echo "  ✗ atuin (not found)"
  command -v direnv >/dev/null 2>&1 && echo "  ✓ direnv" || echo "  ✗ direnv (not found)"
  command -v fzf >/dev/null 2>&1 && echo "  ✓ fzf" || echo "  ✗ fzf (not found)"
  echo ""
  echo "Modern replacements:"
  command -v bat >/dev/null 2>&1 && echo "  ✓ bat (cat)" || echo "  ✗ bat (not found)"
  command -v eza >/dev/null 2>&1 && echo "  ✓ eza (ls)" || echo "  ✗ eza (not found)"
  command -v fd >/dev/null 2>&1 && echo "  ✓ fd (find)" || echo "  ✗ fd (not found)"
  echo ""
fi

# bash - detect login shell
if shopt -q login_shell; then
  echo "=== Bash Environment Initialized ==="
  # Same status checks as above
fi
```

### zsh Completion Caching (Daily Regeneration)
```bash
# Source: https://gist.github.com/ctechols/ca1035271ad134841284
autoload -Uz compinit

# Only regenerate .zcompdump once per day
# (#qN.mh+24) = files modified more than 24 hours ago
if [[ -n ${ZDOTDIR:-$HOME}/.zcompdump(#qN.mh+24) ]]; then
  # Older than 24 hours, regenerate
  compinit
else
  # Fresh cache, skip check (-C flag)
  compinit -C
fi
```

### Tool Integration with Conflict Resolution
```bash
# Source: fzf documentation, atuin/fzf conflict resolution patterns

# Conditional tool initialization
if command -v starship >/dev/null 2>&1; then
  eval "$(starship init zsh)"
fi

if command -v atuin >/dev/null 2>&1; then
  eval "$(atuin init zsh)"
fi

if command -v direnv >/dev/null 2>&1; then
  eval "$(direnv hook zsh)"
fi

# fzf - handle Ctrl-R conflict with atuin
if command -v fzf >/dev/null 2>&1; then
  # If atuin is installed, disable fzf's Ctrl-R binding
  if command -v atuin >/dev/null 2>&1; then
    export FZF_CTRL_R_COMMAND=""
  fi

  # Initialize fzf (0.48.0+ syntax)
  eval "$(fzf --zsh)"
fi
```

### Homebrew Plugin Installation (zsh)
```bash
# Source: Homebrew formulae, zsh-users/zsh-autosuggestions, zsh-users/zsh-syntax-highlighting

# Install via Homebrew
# brew install zsh-autosuggestions zsh-syntax-highlighting

# In .zshrc:
# Autosuggestions
if [[ -f $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]]; then
  source $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh
fi

# ... other config ...

# Syntax highlighting MUST BE LAST
if [[ -f $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ]]; then
  source $(brew --prefix)/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
fi
```

### functions.d Pattern (Auto-Sourcing)
```bash
# Source: Common shell configuration patterns

# In .zshrc or .bashrc:
# Auto-source all function files from functions.d
if [[ -d "$HOME/.zsh/functions.d" ]]; then
  for func_file in $HOME/.zsh/functions.d/*.sh; do
    if [[ -f "$func_file" ]]; then
      source "$func_file"
    fi
  done
fi

# Example function file: ~/.zsh/functions.d/git.sh
# Git shortcuts and helper functions

# Aliases
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git pull'
alias gd='git diff'
alias gco='git checkout'
alias gb='git branch'

# Functions
gac() {
  # Git add all and commit with message
  git add -A && git commit -m "$*"
}

gcp() {
  # Git add, commit, and push
  git add -A && git commit -m "$*" && git push
}
```

### Modern CLI Aliases
```bash
# Source: Modern Unix replacements documentation

# Modern replacements (only if installed)
if command -v bat >/dev/null 2>&1; then
  alias cat='bat'
  # Keep original accessible via \cat or command cat
fi

if command -v eza >/dev/null 2>&1; then
  alias ls='eza --icons --group-directories-first'
  alias ll='eza -alh --icons --group-directories-first'
  alias la='eza -a --icons --group-directories-first'
  alias tree='eza --tree'
fi

if command -v fd >/dev/null 2>&1; then
  alias find='fd'
fi
```

### PATH Deduplication
```bash
# Source: zsh documentation, common bash patterns

# zsh - use typeset -U for automatic deduplication
typeset -U path
path=(
  $HOME/.local/bin
  $HOME/bin
  /opt/homebrew/bin
  $path
)

# bash - manual deduplication
add_to_path() {
  # Only add if not already present
  if [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="$1:$PATH"
  fi
}

add_to_path "$HOME/.local/bin"
add_to_path "$HOME/bin"
```

### Chezmoi Template for Cross-Shell Config
```bash
# Source: chezmoi documentation

# File: dot_zshrc.tmpl
{{- if eq .chezmoi.os "darwin" }}
# macOS-specific configuration

# Homebrew
eval "$(/opt/homebrew/bin/brew shellenv)"

# zsh plugins (macOS only)
source $(brew --prefix)/share/zsh-autosuggestions/zsh-autosuggestions.zsh
{{- end }}

{{- if eq .chezmoi.os "linux" }}
# Linux-specific configuration

# Homebrew on Linux
eval "$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)"
{{- end }}

# Shared configuration (all OSes)
{{ if lookPath "starship" -}}
eval "$(starship init zsh)"
{{ end -}}

{{ if lookPath "atuin" -}}
eval "$(atuin init zsh)"
{{ end -}}
```

### Shell Startup Profiling
```bash
# Source: zsh profiling guides, shell benchmarking documentation

# zsh - use zprof
# Add to TOP of .zshrc:
zmodload zsh/zprof

# ... rest of config ...

# Add to BOTTOM of .zshrc:
zprof

# bash - use time command
time bash -i -c exit

# Benchmark multiple runs (bash or zsh)
for i in {1..10}; do
  /usr/bin/time -f "Run $i: %e seconds" zsh -i -c exit
done
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Oh My Zsh | Direct sourcing | 2020-2024 | 200-500ms → <50ms startup time |
| Custom PS1/PROMPT | starship | 2019-present | Cross-shell consistency, Git-aware, modular |
| export PATH manually | typeset -U path (zsh) | Always available | Automatic deduplication |
| Manual completion | compinit with caching | 2015+ optimization | 100-300ms saved on startup |
| cat | bat | 2018-present | Syntax highlighting, Git integration |
| ls | exa → eza | 2023 fork | exa unmaintained, eza is active fork |
| find | fd | 2017-present | Simpler syntax, respects .gitignore |
| zplugin | zinit | 2020 rename | Same tool, different name |
| fzf 0.47 | fzf 0.48+ | 2024 | New `--zsh` and `--bash` init flags |

**Deprecated/outdated:**
- **Oh My Zsh for performance-focused configs:** Still maintained and popular, but adds significant startup time. Use direct sourcing for speed.
- **exa:** Unmaintained as of 2023, replaced by community fork **eza**
- **zplugin:** Renamed to **zinit**, use new name
- **Sourcing fzf scripts manually:** fzf 0.48+ has simpler `eval "$(fzf --zsh)"` syntax

## Open Questions

Things that couldn't be fully resolved:

1. **Shell startup order preference (Claude's Discretion)**
   - What we know: PATH/env vars can go in .zshenv or .zshrc (zsh), .bash_profile or .bashrc (bash)
   - What's unclear: User's preference for organization
   - Recommendation:
     - zsh: PATH in .zshenv (always available), aliases/functions in .zshrc (interactive only)
     - bash: Everything in .bashrc, .bash_profile sources .bashrc (standard pattern)

2. **Alias naming strategy (Claude's Discretion)**
   - What we know: Can shadow base commands (alias ls=eza) or use new names (alias l=eza)
   - What's unclear: User's preference
   - Recommendation: Shadow with escape hatch knowledge
     - Use `alias ls=eza` for seamless replacement
     - Document escape methods in comments: `\ls` or `command ls` for original
     - User locked decision: use modern replacements (bat, eza, fd)

3. **fzf keybindings with atuin (Claude's Discretion)**
   - What we know: Both want Ctrl-R, atuin should take priority (Phase 4), fzf offers Ctrl-T (files) and Alt-C (dirs)
   - What's unclear: Which fzf keybindings to enable
   - Recommendation:
     - Disable fzf Ctrl-R: `export FZF_CTRL_R_COMMAND=""` before fzf init
     - Keep fzf Ctrl-T (file search) and Alt-C (directory change)
     - atuin owns Ctrl-R for history

4. **zsh plugin approach (Claude's Discretion)**
   - What we know: Direct sourcing is fastest, user wants "as fast as possible"
   - What's unclear: User confirmation of direct sourcing approach
   - Recommendation: Direct sourcing via Homebrew installations
     - Install: `brew install zsh-autosuggestions zsh-syntax-highlighting`
     - Source directly from Homebrew prefix
     - Avoid Oh My Zsh, zinit, or other plugin managers
     - User locked decision: "startup should be as fast as possible"

## Sources

### Primary (HIGH confidence)
- [zsh Completion System Official Documentation](https://zsh.sourceforge.io/Doc/Release/Completion-System.html) - Verified compinit, caching patterns
- [zsh Startup Files Documentation](https://zsh.sourceforge.io/Intro/intro_3.html) - Verified startup file order
- [Bash Startup Files (GNU Manual)](https://www.gnu.org/software/bash/manual/html_node/Bash-Startup-Files.html) - Verified bash file loading
- [fzf Official Shell Integration](https://junegunn.github.io/fzf/shell-integration/) - Verified keybindings, init syntax
- [zsh-autosuggestions GitHub](https://github.com/zsh-users/zsh-autosuggestions) - Installation methods
- [zsh-syntax-highlighting GitHub](https://github.com/zsh-users/zsh-syntax-highlighting) - Installation, must-be-last requirement
- [chezmoi Templating Documentation](https://www.chezmoi.io/user-guide/templating/) - Template syntax, variables
- [Starship Official Docs](https://starship.rs/) - Cross-shell initialization
- [Speed up zsh compinit by checking cache daily](https://gist.github.com/ctechols/ca1035271ad134841284) - Completion caching pattern

### Secondary (MEDIUM confidence)
- [Modern CLI Tools Guide](https://linuxconfig.org/modern-cli-tools-time-to-forget-ls-and-cat) - bat, eza, fd overview
- [Better Stack: eza Explained](https://betterstack.com/community/guides/linux/eza-explained/) - eza usage patterns
- [Homebrew: zsh-autosuggestions](https://formulae.brew.sh/formula/zsh-autosuggestions) - Homebrew install paths
- [Homebrew: zsh-syntax-highlighting](https://formulae.brew.sh/formula/zsh-syntax-highlighting) - Homebrew install paths
- [BashPitfalls - Greg's Wiki](https://mywiki.wooledge.org/BashPitfalls) - Common shell scripting mistakes
- [Shell Script Mistakes - pixelbeat.org](http://www.pixelbeat.org/programming/shell_script_mistakes.html) - Quoting, PATH issues
- [Baeldung: Login vs Non-Login Shells](https://www.baeldung.com/linux/interactive-non-interactive-login-non-login-shells) - Shell type detection
- [Comparison of ZSH Plugin Managers](https://gist.github.com/laggardkernel/4a4c4986ccdcaf47b91e8227f9868ded) - Performance benchmarks
- [direnv Best Practices](https://dev.to/allenap/some-direnv-best-practices-actually-just-one-4864) - Performance rule (don't block)
- [Using direnv to improve workflow](https://platfrastructure.life/post/direnv/) - direnv allow workflow
- [Atuin/fzf Ctrl-R Conflict Resolution](https://gist.github.com/nikvdp/f72ff1776815861c5da78ceab2847be2) - Using atuin with fzf backend
- [zsh Performance Optimization Guides](https://www.dribin.org/dave/blog/archives/2024/01/01/zsh-performance/) - 2024 optimization techniques
- [Profiling ZSH Startup](https://www.bigbinary.com/blog/zsh-profiling) - zprof usage
- [PATH Deduplication in zsh](https://tech.serhatteker.com/post/2019-12/remove-duplicates-in-path-zsh/) - typeset -U pattern
- [Running Shadowed Commands](https://www.baeldung.com/linux/alias-run-shadowed-command) - Escape hatches for aliases

### Tertiary (LOW confidence)
- Multiple blog posts on zsh optimization (2020-2025) - Common patterns verified against official docs
- Community discussions on atuin/fzf conflicts - Solutions verified with official documentation

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All tools have official documentation, Homebrew formulae, active maintenance
- Architecture patterns: HIGH - Verified against official documentation (zsh, bash, chezmoi, fzf) and well-established community patterns
- Pitfalls: MEDIUM-HIGH - Based on official documentation (zsh-syntax-highlighting ordering) and widely documented community experience (Oh My Zsh performance, PATH duplication)
- Tool integration: HIGH - All patterns verified against official documentation (starship, atuin, direnv, fzf)
- Cross-shell compatibility: MEDIUM - Chezmoi templating verified (HIGH), bash/zsh portability based on POSIX standards (HIGH), specific edge cases may exist (MEDIUM)

**Research date:** 2026-02-04
**Valid until:** 2026-03-04 (30 days - shell configuration is stable, but fzf/starship/eza update frequently)
